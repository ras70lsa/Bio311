---
title: "Group 10 TF HW"
author: "Group 10 members"
date: "March 30, 2017"
output:
  html_document: default
  html_notebook: default
---

# Group 10

Ryan St.Pierre (ras70)
Dakota Brinkman (dlb46)
Matt Olson (meo8)
Jeremy Schreck (jes85)

```{r setup, include=FALSE}
library(dplyr);
library("stringr");
library(ggplot2);
library(dplyr);
library(tidyr);
library(RColorBrewer);
library(dendextend);
library(gplots);
library(cluster);
library(igraph)
library(ggraph)
library(gridExtra)
library(grid)
library(gProfileR) ## might need to be installed
```

## Question 1

The biological question we are trying to answer is: how does robust metabolic cycles within yeast cells respond under continuous, glucose limited conditions. Particuarly we aim to answer which clusters of genes control the process, which TF/chromatin modifiers control their state, and how the interaction *between* clusters, trough the transcription regulatory network, contribute to this robust metabolic process. Our primary paper attempts to correlate yeast chromatin state and gene expression during the metabolic process. Our biological question has not changed significantely, and we attempt understand the metabolic cycle within yeast cells with this current homework. In the first homework we investigated what gene expression after periods of starvation reveals about the function of the cell, particularly the metabolic process. In this homework we explored the TFs that control the genes and how the TFs create complex functionality. However, we do aim to better tie the effect of the chromatin state, which is obviously tied to the chromatin modifiers, into our analysis and conclusions. We feel that our understanding of how the chromatin modifies contribute the process was lacking in the prior homework, which was a consequence of us conducting a gene clustering analysis and not a TF analysis. Thus, our biological question has been extended slightly, to further analyze the TF network (particuarly the chromatin modifies) and determine how the network contributes to the metabolic process and whether or TFs regulate genes within similar clusters.

Additionally, we aim to derive more meaningful conclusions about which timepoints in the data contribute to the phases found in the paper (RC, OX, RB, RC). We wish to provide more specificity on the delay between these phases and potentially the mechanism driving them. We believe a transcription focused analysis will be instrumental in getting close in answering some of these questions

From our clustering analysis we were able to determine that there are ~10 clusters in the given expression data, a couple of which were extremely well correlated (temporally). This led us to believe there are 3 or 4 superclusters of significant size (~100-150 genes each) that are instrumental in the metabolic process, a conclusion well supported by the literature provided to us. Additionally, we were able to determine that several clusters display similar oscillatory patterns, with a slight phase (delay) difference. This suggests a "just-in-time supply chain" paradigm, in which components from specific processes" "become available in a highly correlated manner" [Abstract](http://www.nature.com/nsmb/journal/v21/n10/full/nsmb.2881.html#supplementary-information). This is well supported by the findings in the paper, which outlines several phases of the metabolic process: RC, OX, RB, RC. In this homework we seek to further investigate how the TF network contributes to this highly coordinated process. 

The TFs that we have been given, in the primary dataset, for this analysis are **Gcn5p, Esa1p and Set1p**. These are three critical chromatin modifiers, which means they alter the state of the chromatin, allowing other TFs to bind to the DNA, leading to gene expression. The format of this dataset is explained at depth in *Question 2*. Additionally, we were given a broader TF dataset, which is investigated at the end of this analysis and whose investigation will eventually be overlayed our work with the chromatin modifiers. 

## Question 2

We were given TF binding data for 3 TFs (Gcn, Esa, and Set) in the "kuang-2014-TFbinding.csv"" file. In order to analyze the format of the data we first imported it.

```{r}
kuangtf <- read.csv("./datasets/kuang-2014-TFbinding.csv")
time <- read.csv("./datasets/kuang-2014-TFbinding-timepts.csv")
kuangrna <- read.csv("./datasets/kuang-2014-rnaseq-expression.csv")   ##used later - included in the import section of the code for clarity
head(kuangtf)
head(time)
```

```{r}
dim(kuangtf)
dim(time)
```

From the output above it is clear that our data is **time series without knockout**. For each TF there are 14 columns, each of which correspond to a time in the *kuang-2014-TFbinding-timepts* common seperated data file. The rows of the dataset correspond to genes specifically. Thus, each cell of the data gives the binding of the given TF and its time-period (according to the column) for a given gene (given by the column). For simplicity this *binding* measure can be thought of how much TF there *is* for a given gene at that timepoint.

The rows of the dataset contain 1035 genes. We were curious why 1035 genes were given. After further investigation in the paper we found the following statement:

  "Among these [genes in the entire genome], ~1,750 genes were bound by at least two modifiers, and 1,035 genes were bound by all three modifiers, thus suggesting that these enzymes were not necessary for expression of every cycling gene."
  [Landscape of occupancy of chromatin-modifying enzymes in the YMC](http://www.nature.com/nsmb/journal/v21/n10/full/nsmb.2881.html#supplementary-information)

The statement above clarifies which TFs we were given, those in the yeast genome for which all 3 TFs (Gcn, Esa, and Set) did bind. 

### Threshold 

Since we were given time series data, as opposed to p-value data, answering the question "What threshold did the paper use?" was difficult. The three TFs given are already "known" to bind to the 1035 genes given (discussed above). This was determined through a spatiotemporal analysis. However, the paper is more concerned with trying to gain insight from analyzing the temporal attributes of the binding data. In more plain terms, the authors attempt to associate peak TF binding with a given genes expression. This type of analysis was done by directly comparing temporal data, and associating peaks, rather than chosing a threshold value. For this reason we cannot supply a concrete threshold value that was chosen by the paper. In our analysis we use correlation values quite extensively. Thus, it is required for us to have a threshold/cut-off correlation value. This is described in great depth in *Question 3* below, where our analysis pipeline is described.

### Splitting up data and Reformatting

At this point we split the data (associating one dataframe per TF) and reformatted the data. We took the transpose of the original data (such that genes become the columns and Tfs became the rows, with time incrementing down in a row-wise fashion). This allowed us to append the time series data to the dataframe created. Reformatting of the data in this way was necessary for plotting and further analysis below.   

```{r}
Gcn <- kuangtf[,c(1:15)]
Esa <- kuangtf[,c(1,16:29)]
Set <- kuangtf[,c(1,30:43)]

Gcn.data <- as.data.frame(t(Gcn[,-1]))
colnames(Gcn.data) <- Gcn$Gene.ID
Gcn.time <- cbind(Gcn.data, time = time$hour)

Esa.data <- as.data.frame(t(Esa[,-1]))
colnames(Esa.data) <- Esa$Gene.ID
Esa.time <- cbind(Esa.data, time = time$hour)

Set.data <- as.data.frame(t(Set[,-1]))
colnames(Set.data) <- Set$Gene.ID
Set.time <- cbind(Set.data, time = time$hour)
head(Set.time[,1030:1036])
```

## Question 3

At this point we designed our analysis pipeline. However, the data given to us was not in a familiar format (a format seen in class). This forced us to do some original exploration of the data provided before coming up with a comprehensive approach. This exploration is shown below, after which our pipeline is described. 

### Original Exploration - Plotting

Before we procceeded we plotted binding data, over time, for different genes. We overlayed the data from the 3 TFs on the same plot, shown below. We created these plots to get a feeling for the binding data, as an original exploration exercise. We found that the binding data followed oscillatory patterns, all slightly different for each gene. This reminded us of the gene expression data, which also oscillated in a similar way. 

Additionally, these plots gave us some insight on how the TFs for a given gene behave with respect to each other. The plots for the 3 TFs for a given gene are somewhat overlayed on top of each other, peaking at similar times. Of course, the plots for the TFs are not perfectly correlated, especially for some of the genes. However, the findings do highlight the importance of the peaking behavior.

```{R}
ggplot() + geom_line(data=Gcn.time, aes(x = time, y = YAL012W, color="Gcn")) + geom_line(data=Set.time, aes(x = time, y = YAL012W, color="Set")) + geom_line(data=Esa.time, aes(x = time, y = YAL012W, color="Esa")) + labs(x = "Time (hours)", y = "Binding of Gene", title = "YAL001C")

ggplot() + geom_line(data=Gcn.time, aes(x = time, y = YBL033C, color="Gcn")) + geom_line(data=Set.time, aes(x = time, y = YBL033C, color="Set")) + geom_line(data=Esa.time, aes(x = time, y = YBL033C, color="Esa")) + labs(x = "Time (hours)", y = "Binding of Gene", title = "YBL033C")

ggplot() + geom_line(data=Gcn.time, aes(x = time, y = YBL039C, color="Gcn")) + geom_line(data=Set.time, aes(x = time, y = YBL039C, color="Set")) + geom_line(data=Esa.time, aes(x = time, y = YBL039C, color="Esa")) + labs(x = "Time (hours)", y = "Binding of Gene", title = "YBL039C")

ggplot() + geom_line(data=Gcn.time, aes(x = time, y = YBL053W, color="Gcn")) + geom_line(data=Set.time, aes(x = time, y = YBL053W, color="Set")) + geom_line(data=Esa.time, aes(x = time, y = YBL053W, color="Esa")) + labs(x = "Time (hours)", y = "Binding of Gene", title = "YBL053W")

ggplot() + geom_line(data=Gcn.time, aes(x = time, y = YBL087C, color="Gcn")) + geom_line(data=Set.time, aes(x = time, y = YBL087C, color="Set")) + geom_line(data=Esa.time, aes(x = time, y = YBL087C, color="Esa")) + labs(x = "Time (hours)", y = "Binding of Gene", title = "YBL087C")

ggplot() + geom_line(data=Gcn.time, aes(x = time, y = YER086W, color="Gcn")) + geom_line(data=Set.time, aes(x = time, y = YER086W, color="Set")) + geom_line(data=Esa.time, aes(x = time, y = YER086W, color="Esa")) + labs(x = "Time (hours)", y = "Binding of Gene", title = "YER086W")

ggplot() + geom_line(data=Gcn.time, aes(x = time, y = YJL045W, color="Gcn")) + geom_line(data=Set.time, aes(x = time, y = YJL045W, color="Set")) + geom_line(data=Esa.time, aes(x = time, y = YJL045W, color="Esa")) + labs(x = "Time (hours)", y = "Binding of Gene", title = "YJL045W")

ggplot() + geom_line(data=Gcn.time, aes(x = time, y = YGL236C, color="Gcn")) + geom_line(data=Set.time, aes(x = time, y = YGL236C, color="Set")) + geom_line(data=Esa.time, aes(x = time, y = YGL236C, color="Esa")) + labs(x = "Time (hours)", y = "Binding of Gene", title = "YGL236C")
```

These plots gave us insight that the peaking of the TFs might be driving gene expression, or at least they are related. This drove us to a "similarity" or correlation based approach described below.

### Analysis Pipeline 

**Intro**

From the time plots above and the paper we thought we could find which genes are regulated by which TF(s) by doing a temporal analysis. We reasoned that a TF must regulate a gene if that gene has a peak in expression and binding at a similar time interval. Our reasoning for such is that for a given gene to be expressed the chromatin must be accessable. The given TFs regulate the "opening" and "closing" of the chromatin (they are chromatin modifiers). Thus, it is likely to hold that a given TF will bind heavily at a similar time interval of high gene expression, such that it opens the chromatin state and allows other TFs to bind to lead to high gene expression. 

TODO: Possibly add manual plots 

**Design**

However, we found it would be cumbersome to attempt to match up peaks between expression and binding for all the given genes manually (by looking at plots). Thus, we aimed to come up with an analysis pipeline that intuitively found the relationship in a more automated manner. We believed a **correlation** based analysis would be the best way to do this. Our goal was to mimick the p-value approach. However, instead of filtering on p-value we filted on the correlation between expression and binding. 

The first step in our design was choosing *what* exactly we wanted to correlate. As stated above we reasoned that for *a given* gene it is regulated by a TF if the binding data for the TF peaks at the same time as the gene expression. Thus, we wanted to correlate the TF binding data and gene expression for a given gene. This result, we reasoned, would give us a value for how likely the TF regulates the given gene. 

Next in the pipeline we had to chose a filtering threshold. We chose a correlation value of 0.75 to distinguish which TFs regulated which genes. At first the chosing of this correlation value was quite arbitrary. In a sense we were "inventing the wheel" for this type of analysis and thus had no point of reference for a good starting point. We tried different correlation thresholds values throughout the writeup and the changes impact are noted in the location of occurence. Overall, as expected increasing the correlation threshold (closer to one) lowers the number of genes that each TF regulates. Additionally, increasing the threshold increases the likelyhood a gene is bound (here we use the term loosely to mean regulated) by two or all TFs. Lowering the threshold has the converse effect. Eventually the value of 0.75 was chosen because we felt it preserved the integrity of the data (eliminated false positives) and get the TF gene groupings relativelty small (~20-50 genes). We thought it was important to keep the TF binding groups small for the sake of meaningful analysis. Much of our network analysis, done below, is visual. Thus, with groups too large the visuals become crowded and difficult to read. We also tried increasing the correlation value. However, this created groups too small. For example, a correlation value of 0.8 created groupings in which one TF was disjoint from the other (did not regulate any of the genes from the other TFs). We reasoned that given the complexity of the network this was not a practical result.

The final step in the pipeline analysis was a basic network analysis. This entailed creating multiple directional graphs that describe the TF network. This is described in much detail below in the remaining questions.

Note: We identified two limitations of our approach:
1. Our pipeline assumes that if a gene's TF binding data and expression data are strongly correlated they have matching peaks. These peaks is what were really interested. The strong correlation actually implies the two functions follow the same pattern, but the peaks can still be slightly off. For our analysis we reasoned that the assumption that correlated functions have the same peaks (in time) was a fair one to make. We investigated some of these well correlated functions later in our analysis and verified this small assumption.
2. The paper states that the chromatin modifiers and genes are not perfectly, simply correlated. In other words, there might be slight delays between peaks. However, we needed some starting point. We investigated some of these delays manually in the succeeding work.


#Correlation Set Up

To analyze the genes that were regulated by a specific TF, we needed the RNA seq data. This data contained gene expression over 16 time points for all the genes. The first 14 time points matched the 14 time points from the TF data. Then we filtered the genes so all genes from the TF binding data had a matching gene from the RNA seq data. With this data, we created a correlation algorithm that determined how similar the expression and binding data was for a specific gene. We had to come up with this analysis completely on our own, and we are very happy with the results. 

First, we created a dataframe with genes down the rows and expression data over time moving right across the columns. Next, we made a dataframe for each TF containing genes down the rows and binding data over time moving right across the columns. Being careful to make sure the gene columns matched up across these datasets we were able to calculate row wise correlation values for the gene expression data and gene binding data for a given TF. 

The following code makes sure the data is in a format in which the rows can be directly mapped (the same) between the two dataframe described above. 

```{r}

#get the genes in the tf and rna data
TF.genes <- unique(kuangtf[,1])
rna.genes <- unique(kuangrna[,1])

#get rid of duplicated rows in the rna data
rna.unique <- unique(kuangrna)

#filter the rna data for the tf genes
rna.Genes <- filter(rna.unique, rna.unique[,1] %in% TF.genes)

#get the unique genes from this rna data
#may not need to do this again but did it just to be safe
rna.genes.u <- unique(rna.Genes[,1])

#It appears that all of the genes present in the TF data are not present in the rna data
#So need to filter again to get rid of these genes
kuangtf.new <- filter(kuangtf, TF.genes %in% rna.genes.u)

#now remove last two columns so the times add up
rna.new <- rna.Genes[,1:15]

dim(rna.new)
dim(kuangtf.new)

#now extract the different TFs
Gcn.new <- kuangtf.new[,c(1:15)]
dim(Gcn.new)
Esa.new <- kuangtf.new[,c(1,16:29)]
dim(Esa.new)
Set.new <- kuangtf.new[,c(1,30:43)]
dim(Set.new)

#here we see the 69 genes that are in the TF data but not the rnaseq
length(which( ! TF.genes %in% rna.genes))

#sort so that the genes are in the same order
Gcn.sorted <- Gcn.new[match(rna.new[,1], Gcn.new[,1]),]
Esa.sorted <- Esa.new[match(rna.new[,1], Esa.new[,1]),]
Set.sorted <- Set.new[match(rna.new[,1], Set.new[,1]),]
#preview
head(Gcn.sorted)
head(Esa.sorted)
head(Set.sorted)
head(rna.new)
```

#Correlation

At this point we performed the row-wise correlation and appended the results into one dataframe called **df.cors**.  

```{r}
##Need to drop gene name
Gcn.sorted.cor <- select(Gcn.sorted, -Gene.ID)
Esa.sorted.cor <- select(Esa.sorted, -Gene.ID)
Set.sorted.cor <- select(Set.sorted, -Gene.ID)
rna.new.cor <- select(rna.new, -Gene.name)
corValues.Gcn <- sapply(1:nrow(Gcn.sorted.cor), function(i) cor(as.numeric(Gcn.sorted.cor[i,]), as.numeric(rna.new.cor[i,])))
corValues.Esa <- sapply(1:nrow(Esa.sorted.cor), function(i) cor(as.numeric(Esa.sorted.cor[i,]), as.numeric(rna.new.cor[i,])))
corValues.Set <- sapply(1:nrow(Set.sorted.cor), function(i) cor(as.numeric(Set.sorted.cor[i,]), as.numeric(rna.new.cor[i,])))
df.cors <- data.frame(corValues.Gcn, corValues.Esa, corValues.Set) 
head(df.cors)
```

Filtering based on the threshold decided:

```{r}
# But first lets append the gene names to the df.cors dataframe for more informative display
df.cors.w.names <- df.cors
row.names(df.cors.w.names) <- Gcn.sorted$Gene.ID #doesn't matter what set the names comes from - they are all the same 
head(df.cors.w.names)
```


```{r}
Gcn.indexes <- which(df.cors.w.names[,1] > .75)
Gcn.genes.above <- kuangtf.new[Gcn.indexes, 1]
Esa.indexes <- which(df.cors[,2] > .75)
Esa.genes.above <- kuangtf.new[Esa.indexes, 1]
Set.indexes <- which(df.cors[,3] > .75)
Set.genes.above <- kuangtf.new[Set.indexes, 1]
#print first 10 genes for each TF that meet threshold
head(df.cors.w.names[Gcn.indexes,1, drop = FALSE], 10) 
head(df.cors.w.names[Esa.indexes,2, drop = FALSE], 10) 
head(df.cors.w.names[Set.indexes,3, drop = FALSE], 10) 
```

## Question 4

Based on the result of the code below the following is clear (given correlation threshold = 0.75): 
* ESA regulates 19 genes 
* GCN regulates 26 genes 
* SET regualtes 44 genes 

```{r}
df.cors["gene"] = Set.sorted["Gene.ID"]
df.cors.single <- df.cors %>% 
  tidyr::gather(TF, corr, -gene) %>% # cast to long format
  dplyr::select(TF, gene, corr)
df.cors.single.trimmed <- filter(df.cors.single, corr > 0.75)

hits.per.tf <- df.cors.single.trimmed %>% 
               group_by(TF) %>% 
               summarise(ngenes = length(TF))

hits.per.tf
```

Below we changed the threshold values (to 0.8 and 0.5) to observe its effect on the group sizes.

```{r}
df.cors.single.trimmed.8 <- filter(df.cors.single, corr > 0.8)
hits.per.tf.8 <- df.cors.single.trimmed.8 %>% 
               group_by(TF) %>% 
               summarise(ngenes = length(TF))
df.cors.single.trimmed.5 <- filter(df.cors.single, corr > 0.5)
hits.per.tf.5 <- df.cors.single.trimmed.5 %>% 
               group_by(TF) %>% 
               summarise(ngenes = length(TF))
hits.per.tf.8
hits.per.tf.5
```

We wanted to go a step further than just investigating how many genes each TF bound. We wanted to see how many genes were bound by several or all of the TFs. To do this we created a histogram of this distribution, below. From this histogram we can conclude that at the correlation threshold of 0.75 most of the genes are only bound by one TF. We decided that this conclusion is neither justified nor refuted by our knowledge. Also note we tried dropping the correlation value pretty significantly to 0.5 to see its effect on the distribution. The distribution did seem to spread out in this case, as more genes were bound by multiple TFs. However, the change was not a drastic as we thought it would be, relative to the large drop in the threshold.  

```{r}
tfs.per.gene <- df.cors.single.trimmed %>% 
                group_by(gene) %>% 
                summarise(ntfs = length(TF))

tfs.per.gene.5 <- df.cors.single.trimmed.5 %>% 
                group_by(gene) %>% 
                summarise(ntfs = length(TF))

ggplot(tfs.per.gene, aes(x = ntfs)) + 
  geom_histogram(binwidth = 1) +
  labs(x = "Number of TFs", y = "Number of Genes", 
       title = "Distribution of number of TFs per gene  (corr threshold = 0.75)")

ggplot(tfs.per.gene.5, aes(x = ntfs)) + 
  geom_histogram(binwidth = 1) +
  labs(x = "Number of TFs", y = "Number of Genes", 
       title = "Distribution of number of TFs per gene (corr threshold = 0.5)")
```

## Question 5

See the network plots below. We will discuss these networks in 6.

```{r}
df.cors.graph <- graph_from_data_frame(df.cors.single.trimmed)
vcount(df.cors.graph)
ecount(df.cors.graph)
tfs <- unique(df.cors.single.trimmed$TF)
V(df.cors.graph)$type <- V(df.cors.graph)$name %in% tfs
V(df.cors.graph)$shape  <- c("square", "circle")[V(df.cors.graph)$type+1]
V(df.cors.graph)$color  <- c("steelblue", "lightcoral")[V(df.cors.graph)$type+1]
count_components(df.cors.graph)
df.cors.components <- decompose(df.cors.graph)
lapply(df.cors.components, vcount)
lapply(df.cors.components, ecount)

plot(df.cors.components[[1]], 
     layout = layout.auto,
     vertex.label.cex=0.4,
     vertex.label.degree=-90, vertex.label.dist=1)

```

```{r}
df.cors.projection <- bipartite.projection(df.cors.graph)
gene.proj <- df.cors.projection[[1]]
tf.proj <- df.cors.projection[[2]]

tf.shared.cut <- delete.edges(tf.proj, E(tf.proj)[weight < 1])
plot(tf.shared.cut, vertex.label.cex=0.5, vertex.label.dist=0.5 )
```

```{r}
tfs.only.graph <- graph_from_data_frame(df.cors.single.trimmed, directed = TRUE)
l <- layout.circle(tfs.only.graph)

plot(tfs.only.graph, edge.arrow.size=0.3, vertex.shape="none", vertex.label.cex=0.3, edge.curved=0.1, vertex.label.font=2, vertex.label.color="gray40", edge.color="gray85", layout=l)
```

## Question 6

*For the following please note that we are referencing the plots from Q5*

In the undirected graph (the first graph), genes are connected to 1, 2, or 3 TFs. Not all the genes in the TF binding data are represented in this network because we filtered out the genes with correlation values less than 0.75. The genes that are inclued can be seen by a "venn-diagram structure" as shown above. 

In the undirected graph, the edges represent connections between TFs and genes. Tfs and genes that were connected by an edge had TF binding data and RNA seq data that was highly correlated. The nodes represent genes (blue square) and TFs (salmon circle). 

The directed graph (the third graph) is similar, but the edge points from TF to gene because the TF appears to regulate the gene. The nodes in the directed graph represent genes and TFs, which are distinguishable by the name.

For both graphs, there are 3 TFs and 75 target genes. There are 89 edges, meaning that some genes are regulated by multiple TFs.

The second graph shows that all three TFs are connected because each TF is connected to at least one similar target gene.

## Question 7

The out degree for TFs Esa, Gcn, and Set are 19, 26, and 44 respectively.
For the in degree, look at the histogram above. About 58 genes have in-degree 1, about 13 genes have in-degree 2, and about 4 genes have in-degree 3. This shows that about 58 genes, 13 genes, and 4 genes are regulated by only 1, 2, and 3 TFs repectively.

```{r}
#head(df.cors.single.trimmed)
all.profiles <- gprofiler(df.cors.single.trimmed, 
                          organism = "scerevisiae",
                          max_p_value = 0.05,  # set p-value cutoff
                          src_filter = "GO:BP", # only consider GO biological process
                          hier_filtering = "moderate")
all.profiles
```

## Question 8

To synthesize information about our network to think about the function of the TF(s) of interest, we decided to run a GO analysis. Specifically, we ran a GO analysis on only the trimmed dataset (the genes that we previously found were correlated with the TFs and therefore are regulated by the TFs) using gProfileR. The GO analyis split the genes up into 7 categories. These categories had various functions, with a common theme being that they were related to metabolism and the yeast metabolic cycle. This suggests that the function of the target genes is to regulate the metabolic cycle. Specific functional categories that are enriched among the target genes include "generation of precursor metabolites and energy", "purine ribonucleotide metabolic process", and "purine ribonucleoside monophosphate metabolic process", and "tricarboxylic acid cycle". 

We only used 3 TFs in our network analysis. Therefore, all the edges generated were directly between thsoe TFs and the genes of interest, so every gene in our dataset was either a direct target of the TF (i.e. if the gene was included in the trimmed data), or not a target at all. We would need additional TF data to determine if some of the genes are indirect targets of the 3 TFs of interest. 

Next we aimed to discover whether or not any of the TFs regulated the other TFs or themselves. To do this, for each TF we searched its regulated genes in an attempt to discover if these genes where the common gene names of the other TFs.

```{r}
gcn.reg.genes <- as.character(Gcn.genes.above)
gcn.reg.genes
"YGR252W" %in% gcn.reg.genes # Gcn5 not in data overall
"YOR244W" %in% gcn.reg.genes #Esa1
"YHR119W" %in% gcn.reg.genes # Set1 
```

```{r}
esa.reg.genes <- as.character(Esa.genes.above)
esa.reg.genes
"YGR252W" %in% esa.reg.genes # Gcn5 not in data overall
"YOR244W" %in% esa.reg.genes #Esa1 not in data overall
"YHR119W" %in% esa.reg.genes # Set1 
```

```{r}
set.reg.genes <- as.character(Set.genes.above)
set.reg.genes
"YGR252W" %in% set.reg.genes # Gcn5 not in data overall
"YOR244W" %in% set.reg.genes #Esa1 not in data overall
"YHR119W" %in% set.reg.genes # Set1 
```

# Question 9

### TF vs. RNAseq Analysis
```{r}
Gcn.indexes <- which(df.cors[,1] > .75)
Gcn.genes.above <- kuangtf.new[Gcn.indexes, 1]
Esa.indexes <- which(df.cors[,2] > .75)
Esa.genes.above <- kuangtf.new[Esa.indexes, 1]
Set.indexes <- which(df.cors[,3] > .75)
Set.genes.above <- kuangtf.new[Set.indexes, 1]
```
We decided to use a cutoff of .75 for our correlation value.

```{r}
timechar <- c(
"94.95",
"95.31666667",
"95.41666667",
"95.47222222",
"95.59722222",
"95.74166667",
"95.98333333",
"96.24166667",
"96.35555556",
"96.55833333",
"97.05833333",
"97.55833333",
"98.05833333",
"98.56666667")

time <- as.numeric(timechar)
```

We analyzed the Gcn5 TF first
```{r}
Gcn.genes.above.plot <- as.character(Gcn.genes.above)
Gcn.above <- filter(Gcn.new, Gene.ID %in% Gcn.genes.above.plot)
Gcn.t <- t(Gcn.above)
Gcn.t <- Gcn.t[2:nrow(Gcn.t),]
length(Gcn.genes.above.plot)
colnames(Gcn.t) <- as.vector(Gcn.genes.above.plot)
Gcn.t.time <- cbind(Gcn.t, time = time)

Gcn.long <- gather(data.frame(Gcn.t.time), gene, binding, -time)
Gcn.long$time <- as.numeric(as.character(Gcn.long$time))
Gcn.long$binding <- as.numeric(as.character(Gcn.long$binding))

Gcn.long %>% filter(gene %in% Gcn.genes.above.plot[1:10]) %>%
  ggplot(aes(x=time, y=binding, color=gene)) + ggtitle("Gcn5 TFbinding for genes with cor > .75") + geom_line()

Gcn.rna <- filter(rna.new, Gene.name %in% Gcn.genes.above.plot)
Gcn.rna.t <- t(Gcn.rna)
newGenes <- Gcn.rna.t[1,]
Gcn.rna.t2 <- Gcn.rna.t[2:nrow(Gcn.rna.t),]
colnames(Gcn.rna.t2) <- as.vector(newGenes)
Gcn.rna.time <- cbind(Gcn.rna.t2, time = time)
Gcn.rna.long <- gather(data.frame(Gcn.rna.time), gene, expression, -time)
Gcn.rna.long$time <- as.numeric(as.character(Gcn.rna.long$time))
Gcn.rna.long$expression <- as.numeric(as.character(Gcn.rna.long$expression))

Gcn.rna.long %>% filter(gene %in% Gcn.genes.above.plot[1:10]) %>%
  ggplot(aes(x=time, y=expression, color=gene)) + ggtitle("Gcn5 RNAseq for genes with cor > .75") + geom_line()

gene.of.interest <- Gcn.genes.above.plot[1]
p1 <- Gcn.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=binding)) + ggtitle("TFbinding") + geom_line(colour="red")
p2 <- Gcn.rna.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=expression)) + ggtitle("RNAseq Expression") + geom_line(colour="red")
grid.arrange(p1, p2, ncol=2, top=textGrob(as.character(Gcn.genes.above.plot[1]), gp=gpar(fontface="bold")))

gene.of.interest <- Gcn.genes.above.plot[2]
p1 <- Gcn.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=binding)) + ggtitle("TFbinding") + geom_line(colour="red")
p2 <- Gcn.rna.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=expression)) + ggtitle("RNAseq Expression") + geom_line(colour="red")
grid.arrange(p1, p2, ncol=2, top=textGrob(as.character(Gcn.genes.above.plot[2]), gp=gpar(fontface="bold")))


gene.of.interest <- Gcn.genes.above.plot[3]
p1 <- Gcn.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=binding)) + ggtitle("TFbinding") + geom_line(colour="red")
p2 <- Gcn.rna.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=expression)) + ggtitle("RNAseq Expression") + geom_line(colour="red")
grid.arrange(p1, p2, ncol=2, top=textGrob(as.character(Gcn.genes.above.plot[3]), gp=gpar(fontface="bold")))
```

Next was Esa1
```{r}
Esa.genes.above.plot <- as.character(Esa.genes.above)
Esa.above <- filter(Esa.new, Gene.ID %in% Esa.genes.above.plot)
Esa.t <- t(Esa.above)
Esa.t <- Esa.t[2:nrow(Esa.t),]
length(Esa.genes.above.plot)
colnames(Esa.t) <- as.vector(Esa.genes.above.plot)
Esa.t.time <- cbind(Esa.t, time = time)
 
Esa.long <- gather(data.frame(Esa.t.time), gene, binding, -time)
Esa.long$time <- as.numeric(as.character(Esa.long$time))
Esa.long$binding <- as.numeric(as.character(Esa.long$binding))
Esa.long %>% filter(gene %in% Esa.genes.above.plot[1:10]) %>%
  ggplot(aes(x=time, y=binding, color=gene)) + ggtitle("Esa1 TFbinding for genes with cor > .75") + geom_line()

Esa.rna <- filter(rna.new, Gene.name %in% Esa.genes.above.plot)
Esa.rna.t <- t(Esa.rna)
newGenes <- Esa.rna.t[1,]
Esa.rna.t2 <- Esa.rna.t[2:nrow(Esa.rna.t),]
colnames(Esa.rna.t2) <- as.vector(newGenes)
Esa.rna.time <- cbind(Esa.rna.t2, time = time)
Esa.rna.long <- gather(data.frame(Esa.rna.time), gene, expression, -time)
Esa.rna.long$time <- as.numeric(as.character(Esa.rna.long$time))
Esa.rna.long$expression <- as.numeric(as.character(Esa.rna.long$expression))
Esa.rna.long %>% filter(gene %in% Esa.genes.above.plot[1:10]) %>%
  ggplot(aes(x=time, y=expression, color=gene)) + ggtitle("Esa1 RNAseq for genes with cor > .75") + geom_line()

gene.of.interest <- Esa.genes.above.plot[1]
p1 <- Esa.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=binding)) + ggtitle("TFbinding") + geom_line(colour="blue")
p2 <- Esa.rna.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=expression)) + ggtitle("RNAseq Expression") + geom_line(colour="blue")
grid.arrange(p1, p2, ncol=2, top=textGrob(as.character(Esa.genes.above.plot[1]), gp=gpar(fontface="bold")))

gene.of.interest <- Esa.genes.above.plot[2]
p1 <- Esa.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=binding)) + ggtitle("TFbinding") + geom_line(colour="blue")
p2 <- Esa.rna.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=expression)) + ggtitle("RNAseq Expression") + geom_line(colour="blue")
grid.arrange(p1, p2, ncol=2, top=textGrob(as.character(Esa.genes.above.plot[2]), gp=gpar(fontface="bold")))


gene.of.interest <- Esa.genes.above.plot[3]
p1 <- Esa.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=binding)) + ggtitle("TFbinding") + geom_line(colour="blue")
p2 <- Esa.rna.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=expression)) + ggtitle("RNAseq Expression") + geom_line(colour="blue")
grid.arrange(p1, p2, ncol=2, top=textGrob(as.character(Esa.genes.above.plot[3]), gp=gpar(fontface="bold")))
```

And finally Set1
```{r}
Set.genes.above.plot <- as.character(Set.genes.above)
Set.above <- filter(Set.new, Gene.ID %in% Set.genes.above.plot)
Set.t <- t(Set.above)
Set.t <- Set.t[2:nrow(Set.t),]
length(Set.genes.above.plot)
colnames(Set.t) <- as.vector(Set.genes.above.plot)
Set.t.time <- cbind(Set.t, time = time)
 
Set.long <- gather(data.frame(Set.t.time), gene, binding, -time)
Set.long$time <- as.numeric(as.character(Set.long$time))
Set.long$binding <- as.numeric(as.character(Set.long$binding))
Set.long %>% filter(gene %in% Set.genes.above.plot[1:10]) %>%
  ggplot(aes(x=time, y=binding, color=gene)) + ggtitle("Set1 TFbinding for genes with cor > .75") + geom_line()

Set.rna <- filter(rna.new, Gene.name %in% Set.genes.above.plot)
Set.rna.t <- t(Set.rna)
newGenes <- Set.rna.t[1,]
Set.rna.t2 <- Set.rna.t[2:nrow(Set.rna.t),]
colnames(Set.rna.t2) <- as.vector(newGenes)
Set.rna.time <- cbind(Set.rna.t2, time = time)
Set.rna.long <- gather(data.frame(Set.rna.time), gene, expression, -time)
Set.rna.long$time <- as.numeric(as.character(Set.rna.long$time))
Set.rna.long$expression <- as.numeric(as.character(Set.rna.long$expression))
Set.rna.long %>% filter(gene %in% Set.genes.above.plot[1:10]) %>%
  ggplot(aes(x=time, y=expression, color=gene)) + ggtitle("Set1 RNAseq for genes with cor > .75") + geom_line()

gene.of.interest <- Set.genes.above.plot[1]
p1 <- Set.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=binding)) + ggtitle("TFbinding") + geom_line(colour="green")
p2 <- Set.rna.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=expression)) + ggtitle("RNAseq Expression") + geom_line(colour="green")
grid.arrange(p1, p2, ncol=2, top=textGrob(as.character(Set.genes.above.plot[1]), gp=gpar(fontface="bold")))

gene.of.interest <- Set.genes.above.plot[4]
p1 <- Set.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=binding)) + ggtitle("TFbinding") + geom_line(colour="green")
p2 <- Set.rna.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=expression)) + ggtitle("RNAseq Expression") + geom_line(colour="green")
grid.arrange(p1, p2, ncol=2, top=textGrob(as.character(Set.genes.above.plot[4]), gp=gpar(fontface="bold")))


gene.of.interest <- Set.genes.above.plot[3]
p1 <- Set.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=binding)) + ggtitle("TFbinding") + geom_line(colour="green")
p2 <- Set.rna.long %>% filter(gene %in% gene.of.interest) %>%
  ggplot(aes(x=time, y=expression)) + ggtitle("RNAseq Expression") + geom_line(colour="green")
grid.arrange(p1, p2, ncol=2, top=textGrob(as.character(Set.genes.above.plot[3]), gp=gpar(fontface="bold")))
```

### Looking at clusters

```{r}

rnaseq <- read.csv("./datasets/kuang-2014-rnaseq-expression.csv") #local needs to be changed
rnatime <- read.csv("./datasets/kuang-2014-rnaseq-expression-timepts.csv")
# first remember the names
nrna <- rnaseq$Gene.name

# transpose all but the first column (Gene.name)
rnaseq_t_zeros <- as.data.frame(t(rnaseq[,-1]))
colnames(rnaseq_t_zeros) <- nrna

rnaseq_t_zeros.time <- cbind(rnaseq_t_zeros, time = rnatime$hour)

rnaseq_t <- rnaseq_t_zeros[, colSums(rnaseq_t_zeros != 0) > 0]
rnaseq_t.time <- cbind(rnaseq_t, time = rnatime$hour)

rnaseq.cor <- cor(rnaseq_t, use = "pairwise.complete.obs") 
rnaseq.dist <- as.dist(1-rnaseq.cor)

rnaseq.tree <- hclust(rnaseq.dist, method = "complete") 
rnaseq.dend <- as.dendrogram(rnaseq.tree)

rnaseq.clusters <- cut(rnaseq.dend, h = 1.9)

rnaseq.clusters.cluster1 <- cut(rnaseq.clusters$lower[[1]], h = 1.5)
rnaseq.clusters.cluster1.clusterAgain <- cut(rnaseq.clusters.cluster1$lower[[1]], h = 1.2)

rnaseq.clusters.cluster2 <- cut(rnaseq.clusters$lower[[2]], h = 1.6)

rnaseq.clusters.cluster3 <- cut(rnaseq.clusters$lower[[3]], h = 1.3)
rnaseq.clusters.cluster3.cutAgain <- cut(rnaseq.clusters.cluster3$lower[[1]], h = .85)

rnaseq.clusters.cluster4 <- cut(rnaseq.clusters$lower[[4]], h = 1.48)
```

```{r}
kuang <- read.csv("./datasets/kuang-2014-microarray-expression.csv") ##local- needs to be changed 
kuang_t <- as.data.frame(t(kuang[,-1]))
colnames(kuang_t) <- n
kuang_t.cor <- kuang_t %>% cor(use="pairwise.complete.obs")  ##generate correlation measurements
kuang.dist <- as.dist(1 - kuang_t.cor)  ##use correlation to find distance measurements 
k=3
kuang.kmedoids <- pam(kuang.dist, k) # create k-medoids clustering with k clusters
kclusters <- kuang.kmedoids$cluster
kclusters <- kclusters[order.dendrogram(kuang.dend)]

```

```{r}

kcluster1.genes <- names(kclusters[kclusters == 1])
kcluster2.genes <- names(kclusters[kclusters == 2])
kcluster3.genes <- names(kclusters[kclusters == 3])

length(Gcn.genes.above.plot)
in.1 <- kcluster1.genes[match(Gcn.genes.above.plot, kcluster1.genes)]
in.1.filter <-in.1[!is.na(in.1)]
in.2 <- kcluster2.genes[match(Gcn.genes.above.plot, kcluster2.genes)]
in.2.filter <- in.2[!is.na(in.2)]
in.3 <- kcluster3.genes[match(Gcn.genes.above.plot, kcluster3.genes)]
in.3.filter <- in.3[!is.na(in.3)]
in.1.filter
in.2.filter
in.3.filter
length(in.1.filter)
length(in.2.filter)
length(in.3.filter)
```

```{r}
length(Esa.genes.above.plot)
Esa.1 <- kcluster1.genes[match(Esa.genes.above.plot, kcluster1.genes)]
Esa.1.filter <-Esa.1[!is.na(Esa.1)]
Esa.2 <- kcluster2.genes[match(Esa.genes.above.plot, kcluster2.genes)]
Esa.2.filter <- Esa.2[!is.na(Esa.2)]
Esa.3 <- kcluster3.genes[match(Esa.genes.above.plot, kcluster3.genes)]
Esa.3.filter <- Esa.3[!is.na(Esa.3)]
Esa.1.filter
Esa.2.filter
Esa.3.filter
length(Esa.1.filter)
length(Esa.2.filter)
length(Esa.3.filter)
```

```{r}
length(Set.genes.above.plot)
Set.1 <- kcluster1.genes[match(Set.genes.above.plot, kcluster1.genes)]
Set.1.filter <-Set.1[!is.na(Set.1)]
Set.2 <- kcluster2.genes[match(Set.genes.above.plot, kcluster2.genes)]
Set.2.filter <- Set.2[!is.na(Set.2)]
Set.3 <- kcluster3.genes[match(Set.genes.above.plot, kcluster3.genes)]
Set.3.filter <- Set.3[!is.na(Set.3)]
Set.1.filter
Set.2.filter
Set.3.filter
length(Set.1.filter)
length(Set.2.filter)
length(Set.3.filter)
```

```{r}
test <- labels(rnaseq.clusters.cluster1$lower[[1]])

test[match(Gcn.genes.above.plot, test)]
```

```{r}
test[match(Esa.genes.above.plot, test)]
```

```{r}
test[match(Set.genes.above.plot, test)]


#Gcn.genes.above.plot
#Esa.genes.above.plot
#Set.genes.above.plot
```

TODO: talk about TF binding for TF cluster plot
TODO: talk about RNA seq for TF cluster plot
TODO: talk about TF binding and RNA seq plot
TODO: TF clusters vs gene expression clusters? Do they fall into same sets?

# Extension

```{r}
tf.ypd <- read.csv(file="./datasets/harbison-2004-TFbinding-YPD.txt", sep="\t",header=T)
tf.other <- read.csv(file="./datasets/harbison-2004-TFbinding-other.txt", sep="\t",header=T)
head(tf.ypd)
dim(tf.ypd)
head(tf.other)
dim(tf.other)
```

```{r}
tf.ypd.prepped <- na.omit(tf.ypd)
dim(tf.ypd.prepped)
```

Conclusion
TODO: talk briefly about biological questions and major findings
